<!DOCTYPE html>
<html>

<head>
    <title>TicTacToe</title>
</head>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
<script>
    var areaSize = 3;
    var turn = 1;
    var access = 1;
    var tableGenerated = false;
    rootMap = new Map();
    var area = []; // [0,1,2,  3,4,5,  6,7,8]

    function addTable(areaSize) {
        if (tableGenerated == false) {

            var myTableDiv = document.getElementById("left");

            var table = document.createElement('table');

            var tableBody = document.createElement('tbody');
            table.appendChild(tableBody);

            var id = 1;
            for (var i = 0; i < areaSize; i++) {
                var tr = document.createElement('tr');
                tableBody.appendChild(tr);

                for (var j = 0; j < areaSize; j++) {
                    area.push(0.1);
                    var td = document.createElement('td');
                    td.id = "t" + id;
                    tr.appendChild(td);
                    id++;
                }
            }
            myTableDiv.appendChild(table);
            tableGenerated = true;


            // JQUERY CODE
            $(document).ready(function () {
                $('button#generate').css({ 'display': 'none' });
            });
            $(document).ready(function () {
                $('.left table td').hover(function () {
                    if (turn % 2 != 0) { $(this).css({ "background-color": "rgba(0,255,255,0.1)" }); }
                    else { $(this).css({ "background-color": "rgba(255,0,255,0.1)" }); }

                });
                $('.left table td').click(function () { //Squere clicked
                    if ($(this).text() != "O" && $(this).text() != "X" && access == 1) {
                        var Index = $(this).attr('id').substr(1) - 1;

                        if (turn % 2 != 0) { $(this).text("X"); area[Index] = 2; }
                        else { $(this).text("O"); area[Index] = 1; }
                        turn++;
                        check();
                        console.log(myMiniMax(area));
                        console.log(rootMap);
                        // if (turn % 2 == 0) {
                        //     const p = new minimax();
                        //     console.log(p.getBestMove(area))
                        //     console.log(p.nodesMap)
                        // }
                    }
                    else if (access == 0) { reset(); access = 1; }

                });
                $('td').mouseout(function () {
                    $(this).css({ "background-color": "white" });
                });
            });
        }
    }

    function GetAvalibleMoves(board) {

        var moves = [];
        for (var i = 0; i < areaSize * areaSize; i++) {
            if (board[i] == 0.1) {
                moves.push(i);
            }
        }
        return moves;
    }

    function isTerminal(board) {
        if (turn < areaSize * areaSize) {
            var bufferHorizontal = 0;
            for (var x = 1; x < board.length + 1; x++) {
                var bufferVertical = 0;
                var bufferDiagonal = 0;

                if (x <= areaSize) {
                    for (var a = 0; a < areaSize; a++) { bufferVertical += board[x - 1 + a * areaSize]; }
                    if (bufferVertical == areaSize * 2) {
                        return { 'winner': 'X' };
                    }
                    else if (bufferVertical == areaSize) {
                        return { 'winner': 'O' }
                    }
                    if (x == 1) { var helpV = areaSize + 1; }
                    else if (x == areaSize) { var helpV = areaSize - 1; }

                    for (var h = 0; h < areaSize; h++) { bufferDiagonal += board[x - 1 + h * helpV]; }
                    if (bufferDiagonal == areaSize * 2) {
                        return { 'winner': 'X' };
                    }
                    else if (bufferDiagonal == areaSize) {
                        return { 'winner': 'O' }
                    }


                }
                bufferHorizontal += board[x - 1];
                if (x % areaSize == 0) {
                    if (bufferHorizontal == areaSize * 2) {
                        return { 'winner': 'X' };
                    }
                    else if (bufferHorizontal == areaSize) {
                        return { 'winner': 'O' }
                    }
                }
            }

        }
        else {
            return { 'winner': 'draw' };
        }
        return false;
    }

    class minimax {
        constructor(maxDepth = -1) {
            this.maxDepth = maxDepth;
            this.nodesMap = new Map();
        }


        getBestMove(board, Oturn = true, callback = () => { }, depth = 0) {
            //clear nodesMap if the function is called for a new move
            if (depth == 0) this.nodesMap.clear();

            //If the board state is a terminal one, return the heuristic value
            if (isTerminal(board) || depth == this.maxDepth) {
                if (isTerminal(board).winner == 'X') {
                    return 100 - depth;
                } else if (isTerminal(board).winner === 'O') {
                    return -100 + depth;
                }
                return 0;
            }

            if (Oturn) {
                let best = -100;
                GetAvalibleMoves(board).forEach(index => {
                    var newBoard = board;
                    newBoard[index] = 1;
                    var nodeValue = this.getBestMove(newBoard, false, callback, depth + 1);
                    best = Math.max(best, nodeValue);
                    //If it's the main function call, not a recursive one, map each heuristic value with it's moves indices
                    if (depth == 0) {
                        //Comma separated indices if multiple moves have the same heuristic value
                        const moves = this.nodesMap.has(nodeValue)
                            ? `${this.nodesMap.get(nodeValue)},${index}`
                            : index;
                        this.nodesMap.set(nodeValue, moves);
                    }
                });
                if (depth == 0) {
                    let returnValue;
                    if (typeof this.nodesMap.get(best) == "string") {
                        const arr = this.nodesMap.get(best).split(",");
                        const rand = Math.floor(Math.random() * arr.length);
                        returnValue = arr[rand];
                    } else {
                        returnValue = this.nodesMap.get(best);
                    }
                    //run a callback after calculation and return the index
                    callback(returnValue);
                    return returnValue;
                }
                //If not main call (recursive) return the heuristic value for next calculation
                return best;
            }
            if (!Oturn) {
                let best = 100;
                GetAvalibleMoves(board).forEach(index => {
                    var newBoard = board;
                    newBoard[index] = 2;
                    var nodeValue = this.getBestMove(newBoard, true, callback, depth + 1);
                    best = Math.min(best, nodeValue);
                    //If it's the main function call, not a recursive one, map each heuristic value with it's moves indices
                    if (depth == 0) {
                        //Comma separated indices if multiple moves have the same heuristic value
                        const moves = this.nodesMap.has(nodeValue)
                            ? this.nodesMap.get(nodeValue) + "," + index
                            : index;
                        this.nodesMap.set(nodeValue, moves);
                    }
                });
                if (depth == 0) {
                    let returnValue;
                    if (typeof this.nodesMap.get(best) == "string") {
                        const arr = this.nodesMap.get(best).split(",");
                        const rand = Math.floor(Math.random() * arr.length);
                        returnValue = arr[rand];
                    } else {
                        returnValue = this.nodesMap.get(best);
                    }
                    //run a callback after calculation and return the index
                    callback(returnValue);
                    return returnValue;
                }
                //If not main call (recursive) return the heuristic value for next calculation
                return best;
            }
        }

    }

    function myMiniMax(board, Oturn = true, callback = () => { }, depth = 0) {
        if (depth == 0) rootMap.clear();
        if (isTerminal) {
            if (isTerminal.winner == "X") return -100 + depth;
            else if (isTerminal.winner == "O") return 100 - depth;
            return 0;
        }
        if (Oturn) {
            let best = -100;
            GetAvalibleMoves(board).forEach(index => {
                newBoard = board;
                newBoard[index] = 1;
                var rootValue = myMiniMax(newBoard, false, depth + 1);
                best = Math.max(best, rootValue);
            });
            if (depth == 0) {
                const moves = rootMap.has(rootValue)
                    ? `${rootMap.get(rootValue)},${index}`
                    : index;
                rootMap.set(rootValue, moves);
            }
            if (depth == 0) {
                if (typeof rootMap.get(best) == "string") {
                    const arr = rootMap.get(best).split(",");
                    const rand = Math.floor(Math.random() * arr.length);
                    const ret = arr[rand];
                } else {
                    ret = rootMap.get(best);
                }
                //run a callback after calculation and return the index
                callback(ret);
                return ret;
            }
            //If not main call (recursive) return the heuristic value for next calculation
            return best;
        }
        if (!Oturn) {
            let best = -100;
            GetAvalibleMoves(board).forEach(index => {
                newBoard = board;
                newBoard[index] = 2;
                var rootValue = myMiniMax(newBoard, false, depth + 1);
                best = Math.min(best, rootValue);
            });
            if (depth == 0) {
                const moves = rootMap.has(rootValue)
                    ? `${rootMap.get(rootValue)},${index}`
                    : index;
                rootMap.set(rootValue, moves);
            }
            if (depth == 0) {
                if (typeof rootMap.get(best) == "string") {
                    const arr = rootMap.get(best).split(",");
                    const rand = Math.floor(Math.random() * arr.length);
                    const ret = arr[rand];
                } else {
                    ret = rootMap.get(best);
                }
                //run a callback after calculation and return the index
                callback(ret);
                return ret;
            }
            //If not main call (recursive) return the heuristic value for next calculation
            return best;
        }
    }

    function check() {

        var buffer = 0;
        if (turn < areaSize * areaSize) {

            for (var x = 1; x < area.length + 1; x++) {
                var bufferVertical = 0;
                var bufferDiagonal = 0;

                if (x <= areaSize) {
                    //vertical
                    for (var a = 0; a < areaSize; a++) { bufferVertical += area[x - 1 + a * areaSize]; }
                    if (bufferVertical == areaSize * 2 || bufferVertical == areaSize) { access = 0; if (turn % 2 == 0) { alert("X Wins") } else { alert("O Wins") } }

                    // diagonal - first element of the array (0) increase n times by n+1 (0,4,8) and n element of the array (2) increase n times by n-1 (2,4,6)
                    // (0) increase n times by n+1 (0,5,10,15) and n element of the array (3) increase n times by n-1 (3,6,9,12)
                    if (x == 1) { var helpV = areaSize + 1; }
                    else if (x == areaSize) { var helpV = areaSize - 1; }

                    for (var h = 0; h < areaSize; h++) { bufferDiagonal += area[x - 1 + h * helpV]; /*console.log("\n\ntestD: " + testD + " x-1+h*helpV: " +(x-1+h*helpV)+" area[x-1+h*helpV]: "+area[x-1+h*helpV]);*/ }
                    if (bufferDiagonal == areaSize * 2 || bufferDiagonal == areaSize) { access = 0; if (turn % 2 == 0) { alert("X Wins") } else { alert("O Wins") } }


                }

                // horizontal part
                buffer += area[x - 1];
                if (x % areaSize == 0) {
                    if (buffer == areaSize || buffer == areaSize * 2) { access = 0; if (turn % 2 == 0) { alert("X Wins") } else { alert("O Wins") } }
                    buffer = 0;
                }
            }

        }
        else {
            access = 0;
        }


    }
    function reset() {
        turn = 1;
        $(document).ready(function () {
            $('td').each(function () {
                $(this).text("");
            })
            $('p#result').text("");
        });
        area = [0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1];
        access = 1;
    }
    function showUp() {
        for (var x = 1; x < area.length + 1; x++) {
            console.log(area[x - 1]);
            if (x % areaSize == 0) { console.log("\n\n"); }
        }

    }



</script>
<style>
    * {
        margin: 0;
        padding: 0;
        border-spacing: 1;
    }

    body,
    html {
        width: 100%;
        height: 100%;
        overflow-x: hidden;
        overflow-y: hidden;
    }

    div.wrapper {
        display: flex;
        flex-direction: row;
        width: 100%;
        height: 100%;
    }

    div.left {
        width: 50%;
        height: 100%;
        margin-left: 10px;
        margin-top: 5px;
    }

    div.right {
        width: 50%;
        height: 100%;
        display: flex;
        justify-content: start;
        align-items: center;
        font-size: 30px;
        color: red;
    }

    table {
        text-align: center;
        border-bottom: 1px solid black;
        border-left: 1px solid black;
        border-style: none;
        font-size: 40px;
        margin-bottom: 5px;

    }

    td {
        border: 1px solid black;
        width: 80px;
        height: 80px;
    }
</style>

<body>
    <div class="wrapper">
        <div class="left" id="left">
            <p style="margin-bottom:0;">TicTacToe</p>
            <button onclick="reset()">Reset!</button>
            <button onclick="showUp()">Show</button>
            <button onclick="addTable(areaSize)" id="generate">Generate</button>
        </div>
        <div class="right">
            <p id="result" style="text-align: center;"></p>
        </div>
    </div>





</body>

</html>